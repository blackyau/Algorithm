# Algorithm
刷题记录

## LeetCode_155_最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

https://leetcode-cn.com/problems/min-stack/

难度：简单

在类初始化的时候就用两个栈，一个是用来储存栈里面的数，另一个用来储存当前最小的那个数。

每一次 push 的时候，就取 当前最小数栈顶 和 当前数 之间最小的一个数进入最小栈。

相当于空间换时间吧，因为用了 1 倍的空间，储存了在每一个位置上的最小数。

[LeetCode_155.java](src/LeetCode_155.java)


## LeetCode_232_用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）

https://leetcode-cn.com/problems/implement-queue-using-stacks/

难度：简单

要保证两个栈在进行操作到时候，都是整体进行操作。
- 1 号栈要往 2 号栈压入数据时，必须要一次性把所有数据压入。 
- 1 号栈迁移数据至 2 号栈的时候，要确定 2 号栈为空才行。

[LeetCode_232.java](src/LeetCode_232.java)


## LeetCode_239_滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回每一个滑动窗口中的最大值。

https://leetcode-cn.com/problems/sliding-window-maximum/

难度：困难

遍历整个数组，然后使用双端队列（弹出和入队在两边都行的队列）。一直让最大的数字保持在队列的头部，如果尾部来了更大的数字，就把头部弹出。同时如果队列的队头等于 `i-w` 就说明队头已过期，需要弹出队头。

[LeetCode_239.java](src/LeetCode_239.java)


## LeetCode_129_求根节点到叶节点数字之和

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。计算从根节点到叶节点生成的 所有数字之和。

难度：中等

看到题目马上就想到了二叉树的前序遍历，结合递归就行。主要就是不确定当前是第几层要乘以 10 的多少次方，看了题解才知道，可以直接一直传一个值。每递归一次就 * 10 再加上自己的值。

[LeetCode_129](src/LeetCode_129.java)


## LeetCode_236_二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

难度：中等

这个题目主要是对最近公共祖先的理解，要用递归的方式去思考。如果确认 root 节点为 q,p 的公共祖先后，而且 root.left 和 root.right 都不是 p,q 的公共祖先。那么就称 root 为**最近**公共祖先。

把整个数分成两半，使用递归的话，就假设已经找到两边的公共祖先了。那么 4 种情况：

- 左右都为空：左右都没找到，说明无解直接返回 null
- 左有右无：最近公共祖先在左边，就返回左边的。
- 左无右有：最近公共祖先在右边，就返回右边的。
- 左右都有：自己正好在 q 和 p 的中间，那就是自己。

对于最后一种情况，看起来似乎和最开始说的规则有冲突，其实不然。是因为递归出口也包含 `root == q || root == p` 因为最近公共祖先的位置肯定是高于或等于 q 或 p 的所以这里也要作为一个递归出口。

[LeetCode_236](src/LeetCode_236.java)


## LeetCode_113_路径总和II

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点 路径总和等于给定目标和的路径。

难度：中等

使用 DFS 的方式搜索数据，每到达一个节点就用 targetSum 减去当前节点的数值。并把自己添加到 path 里面用于储存一条路径。同时还要注意在每一条路径 return 之前都要把当前 path 的最后一个删掉，不然会导致对其他分支产生污染。这种方法也叫回溯。

[LeetCode_113](src/LeetCode_113.java)


## UVa133_救济金发放

n(n<20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。
输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。

例如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6,10, 7。注意：输出的每个数应当恰好占3列。

https://onlinejudge.org/external/1/133.pdf

通过一个数组来维护每个人走没走，最主要的就是数人数，我是用了求余来确保让数字在 1~n 之间，同时还需要注意数编号时有负数的情况，所以求余的核心代码为 `now = (now + step + n + 1) % (n+1)`

看到这个就想起了，循环队列为了解决数据假满的解决方案。

[UVa133](src/UVa133.java)
